// Generated by CoffeeScript 1.4.0
(function() {
  var Bundle, Dictionary, Message, MockOscPacketGenerator, MockOscPacketParser, TEST_MESSAGES, arrayBuffer, bufferEqual, createInt8Array, desc, expect, i, int8array, isBuffer, length, messageEqual, name, nodeBuffer, osc, _fn, _fn1, _i, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof require === "function") {
    osc = require("../");
    expect = require("expect.js");
  } else {
    osc = window.a2r.osc;
    expect = window.expect;
  }

  Message = osc.Message;

  Bundle = osc.Bundle;

  Dictionary = osc.Dictionary;

  length = function(b) {
    if (b instanceof ArrayBuffer) {
      return b.byteLength;
    } else {
      return b.length;
    }
  };

  nodeBuffer = typeof Buffer === 'function';

  TEST_MESSAGES = [
    {
      msg: new osc.Message("/osc/documentation", "/node/x/y"),
      length: 36
    }, {
      msg: new osc.Message("/node/x/y", "is", [12, "foo"]),
      length: 24
    }, {
      msg: new osc.Message("/node/x/y", osc.Impulse),
      length: 16
    }, {
      msg: new osc.Message("/node/color", "r", Number("0xffaabb")),
      length: 20
    }, {
      msg: new osc.Message("/node/char", "c", "a"),
      length: 20
    }, {
      msg: new osc.Message("/node/x", "d", 25.444),
      length: 20
    }, {
      msg: new osc.Message("/node/setDate", new Date),
      length: 28
    }, {
      msg: new osc.Message("/node/noPayload", [null, false, true, osc.Impulse]),
      length: 24
    }
  ];

  arrayBuffer = new ArrayBuffer(10);

  int8array = new Int8Array(arrayBuffer);

  for (i = _i = 0; _i <= 9; i = ++_i) {
    int8array[i] = Math.round(Math.random() * 255);
  }

  TEST_MESSAGES.push({
    msg: new osc.Message("/foo/data", arrayBuffer),
    length: 32
  });

  createInt8Array = function(buffer) {
    var array;
    if (nodeBuffer && Buffer.isBuffer(buffer)) {
      array = new Int8Array(new ArrayBuffer(buffer.length));
      i = 0;
      while (i < buffer.length) {
        array[i] = buffer[i];
        i++;
      }
      return array;
    } else {
      return new Int8Array(buffer);
    }
  };

  bufferEqual = function(b1, b2) {
    var a1, a2, _results;
    a1 = createInt8Array(b1);
    a2 = createInt8Array(b2);
    expect(a1.byteLength).to.be(a2.byteLength);
    i = 0;
    _results = [];
    while (i < a1.length) {
      expect(a1[i]).to.be(a2[i]);
      _results.push(i++);
    }
    return _results;
  };

  isBuffer = function(o) {
    if (nodeBuffer && Buffer.isBuffer(o)) {
      return true;
    }
    if (o instanceof ArrayBuffer) {
      return true;
    }
    return false;
  };

  messageEqual = function(msg1, msg2) {
    var arg, _j, _len, _ref;
    expect(msg1.address).to.be(msg2.address);
    expect(msg1.typeTag).to.be(msg2.typeTag);
    expect(msg1["arguments"]).to.have.length(msg2["arguments"].length);
    _ref = msg1["arguments"];
    for (i = _j = 0, _len = _ref.length; _j < _len; i = ++_j) {
      arg = _ref[i];
      if (isBuffer(arg)) {
        bufferEqual(arg, msg2["arguments"][i]);
      } else if (arg instanceof Date) {
        expect(arg.valueOf()).to.be(msg2["arguments"][i].valueOf());
      } else if (arg) {
        expect(arg).to.be(msg2["arguments"][i]);
      } else {
        expect(arg === msg2["arguments"][i]).to.be.ok();
      }
    }
    return null;
  };

  MockOscPacketGenerator = (function(_super) {

    __extends(MockOscPacketGenerator, _super);

    function MockOscPacketGenerator(messageOrBundle, dict) {
      MockOscPacketGenerator.__super__.constructor.apply(this, arguments);
      this.buffer = [];
    }

    MockOscPacketGenerator.prototype.writeString = function(string, encoding) {
      if (encoding == null) {
        encoding = "ascii";
      }
      return this.buffer.push(string);
    };

    return MockOscPacketGenerator;

  })(osc.AbstractOscPacketGenerator);

  _ref = osc.NUMBERS;
  _fn = function(name) {
    return MockOscPacketGenerator.prototype["write" + name] = function(value) {
      return this.buffer.push(value);
    };
  };
  for (name in _ref) {
    desc = _ref[name];
    _fn(name);
  }

  MockOscPacketParser = (function(_super) {

    __extends(MockOscPacketParser, _super);

    function MockOscPacketParser() {
      return MockOscPacketParser.__super__.constructor.apply(this, arguments);
    }

    MockOscPacketParser.prototype.readString = function(encoding, move) {
      var value;
      if (move == null) {
        move = true;
      }
      value = this.buffer[this.pos];
      if (move) {
        this.pos++;
      }
      return value;
    };

    MockOscPacketParser.prototype.isEnd = function() {
      return this.buffer.length <= this.pos;
    };

    return MockOscPacketParser;

  })(osc.AbstractOscPacketParser);

  _ref1 = osc.NUMBERS;
  _fn1 = function(name) {
    return MockOscPacketParser.prototype["read" + name] = function(move) {
      var value;
      if (move == null) {
        move = true;
      }
      value = this.buffer[this.pos];
      if (move) {
        this.pos++;
      }
      return value;
    };
  };
  for (name in _ref1) {
    desc = _ref1[name];
    _fn1(name);
  }

  describe("Dictionary", function() {
    describe("constructor", function() {
      it("should take an optional id-to-address map", function() {
        var dict;
        dict = new Dictionary({
          1: "/a2r",
          2: "/a2r/osc"
        });
        return expect(dict.getAddress(2)).to.be("/a2r/osc");
      });
      return it("should take an optional id-to-pattern map", function() {
        var dict;
        dict = new Dictionary(null, {
          1: "//a2r",
          2: "/a2r/{osc,tuio}"
        });
        return expect(dict.getPattern(2)).to.be("/a2r/{osc,tuio}");
      });
    });
    describe(".addAddress", function() {
      return it("should add id-to-address mapping to dictionary", function() {
        var address, dict, id, _j, _k, _results;
        dict = new Dictionary;
        for (id = _j = 0; _j <= 9; id = ++_j) {
          dict.addAddress(id, "/osc/" + id);
        }
        _results = [];
        for (id = _k = 0; _k <= 9; id = ++_k) {
          address = "/osc/" + id;
          expect(dict.getAddress(id)).to.be(address);
          _results.push(expect(dict.getAddressId(address)).to.be(id));
        }
        return _results;
      });
    });
    describe(".removeAddress", function() {
      var dict;
      dict = null;
      beforeEach(function() {
        var id, _j, _results;
        dict = new Dictionary;
        _results = [];
        for (id = _j = 0; _j <= 9; id = ++_j) {
          _results.push(dict.addAddress(id, "/osc/" + id));
        }
        return _results;
      });
      it("should remove address by id", function() {
        dict.removeAddress(2);
        expect(dict.getAddress(2)).to.be(void 0);
        return expect(dict.getAddressId("/osc/2")).to.be(void 0);
      });
      return it("should remove address by address string", function() {
        dict.removeAddress("/osc/2");
        expect(dict.getAddress(2)).to.be(void 0);
        return expect(dict.getAddressId("/osc/2")).to.be(void 0);
      });
    });
    describe(".getAddress", function() {
      return it("should return address for id or undefined if no mapping exist", function() {
        var dict;
        dict = new Dictionary({
          1: "/a2r"
        });
        expect(dict.getAddress(1)).to.be("/a2r");
        return expect(dict.getAddress(2)).to.be(void 0);
      });
    });
    describe(".getAddressId", function() {
      return it("should return address id for address or undefined if no mapping exist", function() {
        var dict;
        dict = new Dictionary({
          1: "/a2r"
        });
        expect(dict.getAddressId("/a2r")).to.be(1);
        return expect(dict.getAddressId("/osc")).to.be(void 0);
      });
    });
    describe(".addPattern", function() {
      return it("should add id-to-pattern mapping to dictionary", function() {
        var dict, id, pattern, _j, _k, _results;
        dict = new Dictionary;
        for (id = _j = 0; _j <= 9; id = ++_j) {
          dict.addPattern(id, "//" + id);
        }
        _results = [];
        for (id = _k = 0; _k <= 9; id = ++_k) {
          pattern = "//" + id;
          expect(dict.getPattern(id)).to.be(pattern);
          _results.push(expect(dict.getPatternId(pattern)).to.be(id));
        }
        return _results;
      });
    });
    describe(".removePattern", function() {
      var dict;
      dict = null;
      beforeEach(function() {
        var id, _j, _results;
        dict = new Dictionary;
        _results = [];
        for (id = _j = 0; _j <= 9; id = ++_j) {
          _results.push(dict.addPattern(id, "//" + id));
        }
        return _results;
      });
      it("should remove pattern by id", function() {
        dict.removePattern(2);
        expect(dict.getPattern(2)).to.be(void 0);
        return expect(dict.getPatternId("//2")).to.be(void 0);
      });
      return it("should remove pattern by pattern string", function() {
        dict.removePattern("//2");
        expect(dict.getPattern(2)).to.be(void 0);
        return expect(dict.getPatternId("//2")).to.be(void 0);
      });
    });
    describe(".getPattern", function() {
      return it("should return pattern for id or undefined if no mapping exist", function() {
        var dict;
        dict = new Dictionary(null, {
          1: "//a2r"
        });
        expect(dict.getPattern(1)).to.be("//a2r");
        return expect(dict.getPattern(2)).to.be(void 0);
      });
    });
    return describe(".getPatternId", function() {
      return it("should return pattern id for pattern or undefined if no mapping exist", function() {
        var dict;
        dict = new Dictionary(null, {
          1: "//a2r"
        });
        expect(dict.getPatternId("//a2r")).to.be(1);
        return expect(dict.getPatternId("//osc")).to.be(void 0);
      });
    });
  });

  describe("Message", function() {
    describe("constructor", function() {
      it("should construct message from address and one argument", function() {
        var msg;
        msg = new Message("/test", 12);
        expect(msg.address).to.be("/test");
        expect(msg.typeTag).to.be("f");
        expect(msg["arguments"]).to.have.length(1);
        return expect(msg["arguments"]).to.contain(12);
      });
      it("should construct message from address and array of arguments", function() {
        var msg;
        msg = new Message("/test", ["a2r", 12]);
        expect(msg.address).to.be("/test");
        expect(msg.typeTag).to.be("sf");
        expect(msg["arguments"]).to.have.length(2);
        expect(msg["arguments"][0]).to.be("a2r");
        return expect(msg["arguments"][1]).to.be(12);
      });
      it("should construct message from address, typetag and array", function() {
        var msg;
        msg = new Message("/test", "si", ["a2r", 12.4]);
        expect(msg.address).to.be("/test");
        expect(msg.typeTag).to.be("si");
        expect(msg["arguments"]).to.have.length(2);
        expect(msg["arguments"][0]).to.be("a2r");
        return expect(msg["arguments"][1]).to.be(12);
      });
      it("should construct message from address and object", function() {
        var msg;
        msg = new Message("/test", {
          type: "i",
          value: 23
        });
        expect(msg.address).to.be("/test");
        expect(msg.typeTag).to.be("i");
        expect(msg["arguments"]).to.have.length(1);
        return expect(msg["arguments"]).to.contain(23);
      });
      return it("should throw an error if a type isn't supported", function() {
        expect(function() {
          return new Message("/test", {
            type: "y",
            value: 23
          });
        }).to.throwError();
        return expect(function() {
          return new Message("/test", "y", 23);
        }).to.throwError();
      });
    });
    describe(".clone", function() {
      return it("should create a copy of the message", function() {
        var msg, msg2;
        msg = new Message("/test", ["hello", 12]);
        msg2 = msg.clone();
        expect(msg).not.to.be(msg2);
        expect(msg["arguments"]).not.to.be(msg2["arguments"]);
        return expect(msg.equal(msg2)).to.be(true);
      });
    });
    describe(".add", function() {
      var msg;
      msg = null;
      beforeEach(function() {
        return msg = new Message("/test");
      });
      it("should return itself", function() {
        return expect(msg.add("foo")).to.be(msg);
      });
      describe("without type code", function() {
        it("should determine typecode for Boolean true", function() {
          msg.add(true);
          return expect(msg.typeTag).to.be("T");
        });
        it("should determine typecode for Boolean false", function() {
          msg.add(false);
          return expect(msg.typeTag).to.be("F");
        });
        it("should determine typecode for null", function() {
          msg.add(null);
          return expect(msg.typeTag).to.be("N");
        });
        it("should determine typecode for Number", function() {
          msg.add(12);
          return expect(msg.typeTag).to.be("f");
        });
        it("should determine typecode for Date", function() {
          msg.add(new Date);
          return expect(msg.typeTag).to.be("t");
        });
        it("should determine typecode for Impulse", function() {
          msg.add(osc.Impulse);
          return expect(msg.typeTag).to.be("I");
        });
        it("should determine typecode for ArrayBuffer", function() {
          msg.add(new ArrayBuffer(4));
          return expect(msg.typeTag).to.be("b");
        });
        if (nodeBuffer) {
          it("should determine typecode for Buffer", function() {
            msg.add(new Buffer(4));
            return expect(msg.typeTag).to.be("b");
          });
        }
        return it("should throw an error for unsupported types", function() {
          return expect(function() {
            return msg.add({});
          }).to.throwError();
        });
      });
      return describe("with type code", function() {
        return it("should cast value", function() {
          msg.add("i", 12.4);
          return expect(msg["arguments"]).to.contain(12);
        });
      });
    });
    return describe(".isPattern", function() {
      it("should return true if address looks like a pattern otherwise it should return false", function() {
        expect(new Message("//foo").isPattern()).to.be(true);
        expect(new Message("/foo*").isPattern()).to.be(true);
        expect(new Message("/foo?").isPattern()).to.be(true);
        expect(new Message("/foo[0-9]").isPattern()).to.be(true);
        return expect(new Message("/foo/bar").isPattern()).to.be(false);
      });
      return it("should cache result of test", function() {
        var msg;
        msg = new Message("/foo");
        expect(msg._isPattern).to.be(void 0);
        msg.isPattern();
        expect(msg._isPattern).to.be(false);
        msg.address = "//foo";
        expect(msg.isPattern()).to.be(false);
        delete msg._isPattern;
        return expect(msg.isPattern()).to.be(true);
      });
    });
  });

  describe("Bundle", function() {
    describe("constructor", function() {
      it("should construct an empty bundle with timetag is time now if called without arguments", function() {
        var bundle;
        bundle = new Bundle;
        expect(bundle.timetag).to.be.a(Date);
        return expect(bundle.elements).to.be.empty();
      });
      it("should construct an empty bundle with timetag is time now if timetag is 1", function() {
        var bundle;
        bundle = new Bundle(1);
        return expect(bundle.timetag).to.be.a(Date);
      });
      it("should construct an bundle with timetag is given date and elements contains given element", function() {
        var bundle, date, msg;
        date = new Date;
        msg = new Message("/test", osc.Impulse);
        bundle = new Bundle(date, msg);
        expect(bundle.timetag).to.be(date);
        expect(bundle.elements).to.have.length(1);
        return expect(bundle.elements).to.contain(msg);
      });
      return it("should construct an bundle with timetag is given date and elements contains given elements", function() {
        var bundle, date, msg, msgs, _j, _len, _results;
        date = new Date;
        msgs = (function() {
          var _j, _results;
          _results = [];
          for (i = _j = 0; _j <= 9; i = ++_j) {
            _results.push(new Message("/test/" + i, osc.Impulse));
          }
          return _results;
        })();
        bundle = new Bundle(date, msgs);
        expect(bundle.timetag).to.be(date);
        expect(bundle.elements).to.have.length(10);
        _results = [];
        for (i = _j = 0, _len = msgs.length; _j < _len; i = ++_j) {
          msg = msgs[i];
          _results.push(expect(bundle.elements[i]).to.be(msg));
        }
        return _results;
      });
    });
    describe(".addElement", function() {
      it("should add a message to elements and return the message", function() {
        var bundle, message;
        bundle = new Bundle;
        message = new Message("/test", osc.Impulse);
        expect(bundle.addElement(message)).to.be(message);
        expect(bundle.elements).to.contain(message);
        return expect(bundle.elements).to.have.length(1);
      });
      return it("should initialize and add a message if called with arguments for message constructor", function() {
        var bundle, message;
        bundle = new Bundle;
        expect(bundle.addElement("/test", 12)).to.be.a(Message);
        expect(bundle.elements).to.have.length(1);
        message = bundle.elements[0];
        expect(message.address).to.be("/test");
        return expect(message["arguments"][0]).to.be(12);
      });
    });
    describe(".add", function() {
      return it("should call addElement and return itself", function() {
        var bundle, called;
        called = false;
        bundle = new Bundle;
        bundle.addElement = function(addr, tag, args) {
          expect(addr).to.be("/test");
          expect(tag).to.be("i");
          expect(args).to.be(5);
          return called = true;
        };
        expect(bundle.add("/test", "i", 5)).to.be(bundle);
        return expect(called).to.be(true);
      });
    });
    return describe(".clone", function() {
      return it("should create a copy of the bundle", function() {
        var bundle, bundle2, elem, _j, _len, _ref2, _results;
        bundle = new Bundle(new Date).add("/test", 12.8);
        bundle2 = bundle.clone();
        expect(bundle).not.to.be(bundle2);
        expect(bundle.timetag).not.to.be(bundle2.timetag);
        expect(bundle.elements).not.to.be(bundle2.elements);
        expect(bundle.timetag.valueOf()).to.be(bundle2.timetag.valueOf());
        _ref2 = bundle.elements;
        _results = [];
        for (i = _j = 0, _len = _ref2.length; _j < _len; i = ++_j) {
          elem = _ref2[i];
          expect(elem).not.to.be(bundle2.elements[i]);
          _results.push(expect(elem.equal(bundle2.elements[i])).to.be(true));
        }
        return _results;
      });
    });
  });

  describe("AbstractOscPacketGenerator", function() {
    describe("generate a message", function() {
      it("should write address, type tag and arguments", function() {
        var array, message, mock;
        message = new osc.Message("/foo/bar", "i", 12);
        mock = new MockOscPacketGenerator(message);
        array = mock.generate();
        expect(array[0]).to.be(message.address);
        expect(array[1]).to.be(",i");
        return expect(array[2]).to.be(12);
      });
      it("should cast values", function() {
        var array, message, mock;
        message = new osc.Message("/foo/bar", "isfc", [12.3, 5, "15.5", "foo"]);
        mock = new MockOscPacketGenerator(message);
        array = mock.generate();
        expect(array[2]).to.be(12);
        expect(array[3]).to.be("5");
        expect(array[4]).to.be(15.5);
        return expect(array[5]).to.be("f".charCodeAt(0));
      });
      return describe("with compressed address string support", function() {
        var dict;
        dict = null;
        beforeEach(function() {
          return dict = new Dictionary({
            1: "/foo",
            2: "/foo/bar"
          }, {
            1: "//foo"
          });
        });
        it("should replace address with '/' and add the id to the arguments", function() {
          var array, message, mock;
          message = new osc.Message("/foo/bar", 12.5);
          mock = new MockOscPacketGenerator(message, dict);
          array = mock.generate();
          expect(array[0]).to.be("/");
          expect(array[1]).to.be(",if");
          expect(array[2]).to.be(2);
          return expect(array[3]).to.be(12.5);
        });
        return it("should replace pattern with '/?' and add the id to the arguments", function() {
          var array, message, mock;
          message = new osc.Message("//foo", 12.5);
          mock = new MockOscPacketGenerator(message, dict);
          array = mock.generate();
          expect(array[0]).to.be("/?");
          expect(array[1]).to.be(",if");
          expect(array[2]).to.be(1);
          return expect(array[3]).to.be(12.5);
        });
      });
    });
    return describe("generate a bundle", function() {
      it("should write '#bundle', timetag and messages", function() {
        var array, bundle, mock;
        bundle = new osc.Bundle(new Date).add("/foo", osc.Impulse).add("/bar", osc.Impulse);
        mock = new MockOscPacketGenerator(bundle);
        array = mock.generate();
        expect(array[0]).to.be("#bundle");
        expect(array[1]).to.be(0);
        expect(array[2]).to.be(1);
        expect(array[3]).to.be(12);
        expect(array[4]).to.be("/foo");
        expect(array[5]).to.be(",I");
        expect(array[6]).to.be(12);
        expect(array[7]).to.be("/bar");
        return expect(array[8]).to.be(",I");
      });
      return it("should convert timetag-date to a NTP date", function() {
        var array, bundle, date, mock, ntp, _j, _results;
        date = new Date;
        date.setTime(date.getTime() + 1000);
        ntp = osc.toNTP(date);
        bundle = new osc.Bundle(date);
        mock = new MockOscPacketGenerator(bundle);
        array = mock.generate();
        _results = [];
        for (i = _j = 0; _j <= 1; i = ++_j) {
          _results.push(expect(array[i + 1]).to.be(ntp[i]));
        }
        return _results;
      });
    });
  });

  describe("AbstractOscPacketParser", function() {
    describe(".parse", function() {
      it("should return a Bundle if the first string is '#bundle'", function() {
        var bundle;
        bundle = new MockOscPacketParser(["#bundle", 0, 1]).parse();
        return expect(bundle).to.be.a(osc.Bundle);
      });
      it("should read bundled messages", function() {
        var bundle, data, elem, messages, msg, msg1, msg2, _j, _k, _len, _len1, _ref2, _results;
        data = ["#bundle", 0, 1];
        msg1 = new osc.Message("/foo", 1);
        msg2 = new osc.Message("/bar", 2);
        messages = [msg1, msg2];
        for (_j = 0, _len = messages.length; _j < _len; _j++) {
          msg = messages[_j];
          data.push(16);
          data.push(msg.address);
          data.push("," + msg.typeTag);
          data.push.apply(data, msg["arguments"]);
        }
        bundle = new MockOscPacketParser(data).parse();
        _ref2 = bundle.elements;
        _results = [];
        for (i = _k = 0, _len1 = _ref2.length; _k < _len1; i = ++_k) {
          elem = _ref2[i];
          _results.push(messageEqual(elem, messages[i]));
        }
        return _results;
      });
      it("should return a Message if the first string is an address", function() {
        var message;
        message = new MockOscPacketParser(["/foo", ",i", 1]).parse();
        return expect(message).to.be.a(osc.Message);
      });
      return describe("with compressed address string support", function() {
        var dict;
        dict = null;
        beforeEach(function() {
          return dict = new Dictionary({
            1: "/foo",
            2: "/foo/bar"
          }, {
            1: "//foo"
          });
        });
        it("should replace address '/' with address from dictionary and should remove id from arguments", function() {
          var message, parser;
          parser = new MockOscPacketParser(["/", ",if", 2, 12.8], null, dict);
          message = parser.parse();
          expect(message.address).to.be("/foo/bar");
          expect(message.typeTag).to.be("f");
          expect(message["arguments"]).to.have.length(1);
          return expect(message["arguments"][0]).to.be(12.8);
        });
        return it("should replace address '/?' with pattern from dictionary and should remove id from arguments", function() {
          var message, parser;
          parser = new MockOscPacketParser(["/?", ",if", 1, 12.8], null, dict);
          message = parser.parse();
          expect(message.address).to.be("//foo");
          expect(message.typeTag).to.be("f");
          expect(message["arguments"]).to.have.length(1);
          return expect(message["arguments"][0]).to.be(12.8);
        });
      });
    });
    return describe(".readTimetag", function() {
      return it("should read a 64bit NTP time from buffer and convert it to a Date object", function() {
        var date, hi, lo, mock;
        hi = 3314714339;
        lo = 51539608;
        mock = new MockOscPacketParser([hi, lo]);
        date = mock.readTimetag();
        expect(date.ntpSeconds).to.be(hi);
        expect(date.ntpFraction).to.be(lo);
        expect(date.getUTCDate()).to.be(14);
        expect(date.getUTCMonth()).to.be(0);
        expect(date.getUTCFullYear()).to.be(2005);
        expect(date.getUTCHours()).to.be(17);
        expect(date.getUTCMinutes()).to.be(58);
        expect(date.getUTCSeconds()).to.be(59);
        return expect(date.getMilliseconds()).to.be(12);
      });
    });
  });

  describe("OscArrayBufferPacketGenerator", function() {
    it("should generate packets with correct size", function() {
      var msg, packet, _j, _len, _results;
      _results = [];
      for (_j = 0, _len = TEST_MESSAGES.length; _j < _len; _j++) {
        msg = TEST_MESSAGES[_j];
        packet = new osc.OscArrayBufferPacketGenerator(msg.msg).generate();
        _results.push(expect(length(packet)).to.be(msg.length));
      }
      return _results;
    });
    return it("should generate packets that are parseable by OscArrayBufferPacketParser", function() {
      var message, msg, packet, _j, _len, _results;
      _results = [];
      for (_j = 0, _len = TEST_MESSAGES.length; _j < _len; _j++) {
        msg = TEST_MESSAGES[_j];
        packet = new osc.OscArrayBufferPacketGenerator(msg.msg).generate();
        message = new osc.OscArrayBufferPacketParser(packet).parse();
        _results.push(messageEqual(msg.msg, message));
      }
      return _results;
    });
  });

  if (nodeBuffer) {
    describe("OscArrayBufferPacketGenerator", function() {
      it("should generate packets with correct size", function() {
        var msg, packet, _j, _len, _results;
        _results = [];
        for (_j = 0, _len = TEST_MESSAGES.length; _j < _len; _j++) {
          msg = TEST_MESSAGES[_j];
          packet = new osc.OscBufferPacketGenerator(msg.msg).generate();
          _results.push(expect(length(packet)).to.be(msg.length));
        }
        return _results;
      });
      return it("should generate packets that are parseable by OscBufferPacketParser", function() {
        var message, msg, packet, _j, _len, _results;
        _results = [];
        for (_j = 0, _len = TEST_MESSAGES.length; _j < _len; _j++) {
          msg = TEST_MESSAGES[_j];
          packet = new osc.OscBufferPacketGenerator(msg.msg).generate();
          message = new osc.OscBufferPacketParser(packet).parse();
          _results.push(messageEqual(msg.msg, message));
        }
        return _results;
      });
    });
  }

  if (nodeBuffer) {
    describe("OscBufferPacketGenerator", function() {
      it("should terminate a string with 0", function() {
        var buffer, string, _j, _k, _results;
        string = "/a";
        buffer = new osc.Message(string, osc.Impulse).toBuffer();
        for (i = _j = 0; _j <= 1; i = ++_j) {
          expect(buffer[i]).to.be(string.charCodeAt(i));
        }
        _results = [];
        for (i = _k = 2; _k <= 3; i = ++_k) {
          _results.push(expect(buffer[i]).to.be(0));
        }
        return _results;
      });
      return it("should add additional null characters to string to make the total number of bits a multiple of 32", function() {
        var buffer, string, _j, _k, _results;
        string = "/foo";
        buffer = new osc.Message(string, osc.Impulse).toBuffer();
        for (i = _j = 0; _j <= 3; i = ++_j) {
          expect(buffer[i]).to.be(string.charCodeAt(i));
        }
        _results = [];
        for (i = _k = 4; _k <= 7; i = ++_k) {
          _results.push(expect(buffer[i]).to.be(0));
        }
        return _results;
      });
    });
  }

}).call(this);
